<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üëëSkylord Vibrasiüëë Brainwave Player</title>
    <style>
        /* CSS Baru untuk membuat tampilan penuh layar */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex; /* Menggunakan Flexbox untuk centering */
            justify-content: center;
            align-items: center;
            background-color: #000; /* Warna latar belakang tetap hitam */
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: auto; /* Memungkinkan scrolling jika konten melebihi layar */
        }

        /* --- CSS BARU: Password Overlay --- */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Sedikit transparan agar terlihat gelap */
            z-index: 1000; /* Pastikan di atas semua elemen lain */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #00ff00;
            font-size: 1.2em;
            padding: 20px;
        }

        #password-overlay input[type="password"] {
            padding: 10px;
            margin: 15px 0;
            width: 80%;
            max-width: 300px;
            border: 2px solid #00ff00;
            background-color: #111;
            color: #fff;
            border-radius: 5px;
            font-size: 1em;
        }

        #password-overlay button {
            padding: 10px 20px;
            background-color: #00ff00;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        #password-overlay button:hover {
            background-color: #00cc00;
        }
        /* ----------------------------------- */


        .player-container {
            display: none; /* UBAH: Sembunyikan secara default, akan ditampilkan oleh JS setelah kata sandi benar */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #000;
            color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            width: 90%; /* Menggunakan persentase agar lebih responsif di berbagai layar */
            max-width: 500px;
            margin: 20px auto;
            text-align: center;
        }

        .player-container h1 {
            color: #00ff00;
            margin-bottom: 20px; 
            line-height: 1.2;
        }
        
        #titleSub {
            font-size: 0.7em;
        }

        /* Menyembunyikan elemen input file yang tidak terpakai */
        .player-container input[type="file"], .player-container .file-label {
            display: none;
        }

        .player-container .option-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-container .option-group label {
            margin: 0;
        }

        .player-container .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-container button {
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            white-space: nowrap;
        }
        
        #playBtn, #pauseBtn {
            background-color: #00ff00;
            color: black;
        }
        
        #playBtn:hover, #pauseBtn:hover {
            background-color: #00cc00;
        }

        #stopBtn {
            background-color: #ff0000;
            color: white;
        }

        #stopBtn:hover {
            background-color: #cc0000;
        }
        
        #downloadBtn {
            background-color: #007BFF;
            color: white;
        }
        
        #downloadBtn:hover {
            background-color: #0056b3;
        }
        
        .player-container #status {
            margin-top: 20px;
            font-size: 14px;
            color: #00ff00;
            min-height: 20px;
        }
        
        .player-container #timer {
            font-size: 1.2em;
            font-weight: bold;
            color: #FFFFFF;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="password-overlay">
    <h2>Akses Terkunci üîê</h2>
    <p>Masukkan Kata Sandi:</p>
    <input type="password" id="passwordInput" placeholder="Kata Sandi Rahasia" autocomplete="off">
    <button id="submitPasswordBtn">Masuk üîë</button>
    <p id="passwordMessage" style="color: red; margin-top: 10px;"></p>
</div>
<div class="player-container">
    <h1 id="playerTitle">
        <span id="titleMain">üëëSkylord Vibrasiüëë</span><br>
        <span id="titleSub">üéß Brainwave Murni Player üéß</span>
    </h1>
    
    <div class="option-group">
        <input type="checkbox" id="pinkNoiseToggle" checked>
        <label for="pinkNoiseToggle">Aktifkan Noise üîä</label>
    </div>
    
    <div class="option-group">
        <input type="checkbox" id="loopToggle">
        <label for="loopToggle">Ulangi üîÑ (Loop)</label>
    </div>

    <div class="controls">
        <button id="playBtn">Play ‚ñ∂Ô∏è</button>
        <button id="pauseBtn" disabled style="display:none;">Pause ‚è∏Ô∏è</button>
        <button id="stopBtn" disabled>Stop ‚èπÔ∏è</button>
        <button id="downloadBtn">Download üõÖ</button>
    </div>
    <div id="status"></div>
    <div id="timer">00:00</div>
</div>

<script>
    // --- LOGIKA KATA SANDI BARU ---
    const SECRET_PASSWORD = "skylord1983#aura"; // GANTI KATA SANDI INI!
    const passwordOverlay = document.getElementById('password-overlay');
    const passwordInput = document.getElementById('passwordInput');
    const submitPasswordBtn = document.getElementById('submitPasswordBtn');
    const passwordMessage = document.getElementById('passwordMessage');
    const playerContainer = document.querySelector('.player-container');

    function checkPassword() {
        if (passwordInput.value === SECRET_PASSWORD) {
            // Kata sandi benar, sembunyikan overlay dan tampilkan player
            passwordOverlay.style.display = 'none';
            playerContainer.style.display = 'flex'; // Tampilkan player-container
            // Lanjutkan proses loading SBG data
            loadSbgData(); 
        } else {
            // Kata sandi salah
            passwordMessage.textContent = 'Kata Sandi Salah. Akses Ditolak.';
            passwordInput.value = ''; // Kosongkan input
        }
    }
    // -----------------------------------
    
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusDiv = document.getElementById('status');
    const timerDiv = document.getElementById('timer');
    const pinkNoiseToggle = document.getElementById('pinkNoiseToggle');
    const loopToggle = document.getElementById('loopToggle');

    let audioContext;
    let oscillatorL, oscillatorR;
    let pinkNoiseSource;
    
    // Variabel untuk Audio Eksternal
    let externalAudioBuffer = null;
    let externalAudioSource = null;
    // BARU: Array untuk menyimpan sumber loop tambahan (untuk pause/stop yang lebih bersih)
    let externalAudioLoopSources = []; 

    let sbgData = null;
    let isPlaying = false;
    let isPaused = false;
    let timerInterval;
    let playStartTime;
    let totalDuration = 0; // Durasi yang ditampilkan (akan sama dengan sbgDuration)
    let sbgDuration = 0; // Durasi actual dari data SBG
    let pauseOffset = 0;
    
    // NAMA FILE AUDIO EKSTERNAL. PASTIKAN FILE INI BERADA DI FOLDER YANG SAMA!
    const EXTERNAL_AUDIO_FILENAME = 'file.wav'; 
    const MASTER_VOLUME = 0.4; // Volume master mix

    // DATA SBG ANDA
    const sbgContentToLoad = `
        electrofield: pink/10 300+10.5/90
bodystate: pink/5 300+3.2/95
liftedstate: pink/2 300+5.2/98
aurastate: pink/0 300+7.7/100
alloff:  -

NOW electrofield
+00:02:00 electrofield ->
+00:05:00 bodystate
+00:10:00 bodystate ->
+00:11:00 liftedstate
+00:15:00 liftedstate ->
+00:16:00 aurastate
+00:18:00 aurastate ->
+00:20:00 alloff
    `;

    function parseTime(timeStr) {
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
    }

    function createPinkNoiseBuffer(audioContext, duration) {
        // Implementasi Pink Noise (tetap sama)
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99474 * b1 + white * 0.0750759;
            b2 = 0.97509 * b2 + white * 0.1538520;
            b3 = 0.86200 * b3 + white * 0.3104856;
            b4 = 0.00000 * b4 + white * 0.5329522;
            b5 = -0.18500 * b5 + white * 0.1147000;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.115926;
            b6 = white * 0.115926;
            output[i] *= 0.1;
        }
        return buffer;
    }

    function parseSbg(text) {
        // Implementasi Parser SBG (tetap sama)
        const lines = text.split('\n').filter(line => line.trim() !== '');
        const presets = {};
        const events = [];
        
        presets['alloff'] = {
            noiseType: 'pink',
            noiseVol: 0,
            freqL: 0,
            freqR: 0,
            toneVol: 0
        };

        lines.forEach(line => {
            line = line.trim();
            if (line.startsWith('##') || line.startsWith('-SE')) {
                return;
            }
            const presetMatch = line.match(/^(\w+):\s+([\w\/]+)\s+([\d.]+)\+([\d.]+)\/([\d.]+)/);
            if (presetMatch) {
                const name = presetMatch[1];
                const noiseParts = presetMatch[2].split('/');
                const noiseType = noiseParts[0];
                const noiseVol = parseFloat(noiseParts[1] || 0) / 100;
                const baseFreq = parseFloat(presetMatch[3]);
                const beatFreq = parseFloat(presetMatch[4]);
                const toneVol = parseFloat(presetMatch[5]) / 100;

                presets[name] = {
                    noiseType: noiseType,
                    noiseVol: noiseVol,
                    freqL: baseFreq,
                    freqR: baseFreq + beatFreq,
                    toneVol: toneVol
                };
            }
            const eventMatch = line.match(/^(\+|NOW)\s*([\d:.]*)\s*(\w+)/);
            if (eventMatch) {
                const timeStr = eventMatch[2];
                const presetName = eventMatch[3];
                if (presets[presetName]) {
                    if (eventMatch[1] === 'NOW') {
                        events.push({ time: 0, preset: presetName });
                    } else if (eventMatch[1] === '+') {
                        const timeInSeconds = parseTime(timeStr);
                        events.push({ time: timeInSeconds, preset: presetName });
                    }
                }
            }
        });
        events.sort((a, b) => a.time - b.time);
        return { presets, events };
    }

    function formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    // FUNGSI BARU: Memuat File Audio Eksternal
    async function loadExternalAudio() {
        if (!window.fetch || !window.AudioContext) {
            return;
        }
        
        statusDiv.textContent = `Memuat (${EXTERNAL_AUDIO_FILENAME}), mohon tunggu...`;
        
        try {
            if (!audioContext || audioContext.state === 'closed') {
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const response = await fetch(EXTERNAL_AUDIO_FILENAME);
            if (!response.ok) {
                 throw new Error(`Gagal memuat file: ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();

            externalAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            statusDiv.textContent = `File eksternal berhasil dimuat. Siap dicampur!`;
            
        } catch (error) {
            statusDiv.textContent = `Gagal memuat atau mendekode audio eksternal: ${error.message}. Mode Murni Brainwave Aktif.`;
            externalAudioBuffer = null;
            console.error(error);
        } finally {
            if (sbgData && sbgData.events.length > 0) {
                 playBtn.disabled = false;
                 statusDiv.textContent = `Vibrasi Aura Korektor Otomatis Berhasil Ditransfer Skylord ‚úì Play dan Tunggu`;
            }
        }
    }
    
    // FUNGSI MODIFIKASI: Menghentikan SBG Tepat Waktu
    function updateStatusAndTimer() {
        if (!sbgData || !sbgData.events.length) return; 
        
        const elapsedTime = (Date.now() - playStartTime) / 1000 + pauseOffset;
        
        const isSbgFinished = !loopToggle.checked && elapsedTime >= sbgDuration;

        if (isSbgFinished) {
            // HENTIKAN HANYA GENERATOR BRAINWAVE
            if (oscillatorL) {
                oscillatorL.stop(audioContext.currentTime);
                oscillatorL.disconnect();
                oscillatorL = null;
            }
            if (oscillatorR) {
                oscillatorR.stop(audioContext.currentTime);
                oscillatorR.disconnect();
                oscillatorR = null;
            }
            if (pinkNoiseSource) {
                pinkNoiseSource.stop(audioContext.currentTime);
                pinkNoiseSource.disconnect();
                pinkNoiseSource = null;
            }

            // PERIKSA STATUS AUDIO EKSTERNAL
            if (externalAudioSource) {
                clearInterval(timerInterval);
                isPlaying = false;
                
                statusDiv.textContent = 'Program Sukses !!! Audio Eksternal Berlanjut...';
                
                // Menonaktifkan tombol pause/resume
                pauseBtn.disabled = true; 
                playBtn.disabled = true;
            } else {
                stopAudio(); 
                statusDiv.textContent = 'Program Brainwave Selesai. Selamat!';
            }
            
            timerDiv.textContent = `Durasi ${formatDuration(sbgDuration)} / ${formatDuration(sbgDuration)}`;
            
        } else {
            // JIKA BELUM SELESAI
            const formattedTime = formatDuration(elapsedTime);
            const formattedDuration = formatDuration(totalDuration);
            timerDiv.textContent = `Mulai ${formattedTime} / ${formattedDuration}`;
            
            // Update status frekuensi
            let currentEvent = sbgData.events[0];
            for (let i = 0; i < sbgData.events.length; i++) {
                if (sbgData.events[i].time <= elapsedTime) {
                    currentEvent = sbgData.events[i];
                } else {
                    break;
                }
            }
            
            const preset = sbgData.presets[currentEvent.preset];
            if (preset) {
                statusDiv.textContent = `Frekuensi saat ini: ${preset.freqL.toFixed(2)} Hz / ${preset.freqR.toFixed(2)} Hz`;
            }
        }
    }


    // FUNGSI MODIFIKASI: Start Audio untuk Mode Campuran (LOGIKA LOOP/STOP AUDIO EKSTERNAL DIPERBARUI)
    function startAudio() {
        if (!sbgData || isPlaying) {
            return;
        }

        isPlaying = true;
        isPaused = false;
        
        if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        audioContext.resume().then(() => {
            const masterGain = audioContext.createGain();
            masterGain.gain.setValueAtTime(MASTER_VOLUME, audioContext.currentTime); 
            masterGain.connect(audioContext.destination);

            const startTime = audioContext.currentTime;
            
            // LOGIKA AUDIO EKSTERNAL
            if (externalAudioBuffer) {
                // Bersihkan sumber loop lama
                externalAudioLoopSources = [];
                
                externalAudioSource = audioContext.createBufferSource();
                externalAudioSource.buffer = externalAudioBuffer;
                
                externalAudioSource.connect(masterGain); 
                
                const offset = pauseOffset;
                
                // Durasi audio eksternal
                const externalAudioDuration = externalAudioBuffer.duration;
                
                // Waktu penghentian yang dijadwalkan (akhir program SBG dalam waktu AudioContext)
                const stopPoint = startTime + sbgDuration - offset; 

                // Menghitung berapa kali audio eksternal perlu diulang untuk menutupi sbgDuration
                const totalDurationNeeded = sbgDuration - offset;
                // Hitung loop yang diperlukan (termasuk putaran pertama)
                const numLoops = Math.ceil(totalDurationNeeded / externalAudioDuration);
                
                let currentStartTime = 0; // Waktu relatif terhadap start AudioContext
                let currentOffset = offset;
                
                for (let i = 0; i < numLoops; i++) {
                    const durationToPlay = Math.min(externalAudioDuration - currentOffset, totalDurationNeeded - currentStartTime);
                    
                    if (durationToPlay > 0) {
                        // Start: Waktu saat ini + waktu di mana pengulangan ini dimulai
                        const startPoint = startTime + currentStartTime;
                        
                        let sourceToSchedule;
                        
                        if (i === 0) {
                            sourceToSchedule = externalAudioSource; // Sumber utama
                            sourceToSchedule.start(startPoint, currentOffset); 
                        } else {
                            // Untuk pengulangan berikutnya, buat sumber baru
                            sourceToSchedule = audioContext.createBufferSource();
                            sourceToSchedule.buffer = externalAudioBuffer;
                            sourceToSchedule.connect(masterGain);
                            
                            // Mulai dari 0 pada setiap loop baru
                            sourceToSchedule.start(startPoint, 0); 
                            
                            // Simpan referensi ke loopSource agar bisa dihentikan di stopAudio
                            externalAudioLoopSources.push(sourceToSchedule); 
                        }
                        
                        // Hentikan sumber ini tepat pada waktu akhir SBG 
                        // Jika durasinya melebihi stopPoint, panggil stop() pada waktu tersebut.
                        sourceToSchedule.stop(stopPoint); 
                        
                        currentStartTime += durationToPlay;
                        currentOffset = 0; // Setelah putaran pertama, offset kembali ke 0
                    }
                }
                
                externalAudioSource.onended = () => {
                    // Hanya untuk debug atau jika terjadi kesalahan
                };
            }
            
            // LOGIKA BRAINWAVE GENERATOR
            oscillatorL = audioContext.createOscillator();
            oscillatorR = audioContext.createOscillator();
            
            const gainL = audioContext.createGain();
            const gainR = audioContext.createGain();
            const pannerL = audioContext.createStereoPanner();
            const pannerR = audioContext.createStereoPanner();
            pannerL.pan.setValueAtTime(-1, audioContext.currentTime);
            pannerR.pan.setValueAtTime(1, audioContext.currentTime);
            
            let pinkNoiseGain = null;
            const isPinkNoiseEnabled = pinkNoiseToggle.checked;
            
            if (isPinkNoiseEnabled) {
                const firstPreset = sbgData.presets[sbgData.events[0].preset];
                if (firstPreset && firstPreset.noiseType === 'pink') {
                    pinkNoiseSource = audioContext.createBufferSource();
                    // Untuk pink noise, kita bisa menggunakan loop jika loopToggle diaktifkan, atau tidak
                    pinkNoiseSource.buffer = createPinkNoiseBuffer(audioContext, sbgDuration); 
                    pinkNoiseSource.loop = loopToggle.checked; 
                    
                    pinkNoiseGain = audioContext.createGain(); 
                    pinkNoiseSource.connect(pinkNoiseGain);
                    pinkNoiseGain.connect(masterGain);
                    pinkNoiseSource.start(0, pauseOffset);
                }
            }
            
            oscillatorL.type = 'sine';
            oscillatorR.type = 'sine';
            
            oscillatorL.connect(gainL);
            gainL.connect(pannerL);
            pannerL.connect(masterGain);
            oscillatorR.connect(gainR);
            gainR.connect(pannerR);
            pannerR.connect(masterGain);

            sbgData.events.forEach(event => {
                const preset = sbgData.presets[event.preset];
                const scheduledTime = startTime + event.time - pauseOffset;

                if (scheduledTime >= startTime) {
                    if (preset) {
                        gainL.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                        gainR.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                        oscillatorL.frequency.linearRampToValueAtTime(preset.freqL, scheduledTime);
                        oscillatorR.frequency.linearRampToValueAtTime(preset.freqR, scheduledTime);
                        
                        if (pinkNoiseGain) {
                            pinkNoiseGain.gain.linearRampToValueAtTime(preset.noiseVol, scheduledTime);
                        }
                    }
                }
            });

            oscillatorL.start(startTime, pauseOffset);
            oscillatorR.start(startTime, pauseOffset);
            
            playStartTime = Date.now();
            timerInterval = setInterval(updateStatusAndTimer, 1000);
            
            playBtn.disabled = true;
            playBtn.style.display = 'none';
            pauseBtn.disabled = false;
            pauseBtn.style.display = 'inline-block';
            stopBtn.disabled = false;
        });
    }

    // FUNGSI MODIFIKASI: Stop Audio untuk Semua Sumber (Termasuk Sumber Loop Eksternal)
    function stopAudio() {
        if (!isPlaying && !isPaused && !externalAudioSource) {
            return;
        }
        
        // Hentikan Brainwave Generator
        if (oscillatorL) {
            oscillatorL.stop();
            oscillatorL.disconnect();
            oscillatorL = null;
        }
        if (oscillatorR) {
            oscillatorR.stop();
            oscillatorR.disconnect();
            oscillatorR = null;
        }
        if (pinkNoiseSource) {
            pinkNoiseSource.stop();
            pinkNoiseSource.disconnect();
            pinkNoiseSource = null;
        }

        // Hentikan Audio Eksternal Utama
        if (externalAudioSource) {
            externalAudioSource.stop();
            externalAudioSource.disconnect();
            externalAudioSource = null;
        }
        
        // Hentikan Audio Eksternal Loop Tambahan
        externalAudioLoopSources.forEach(source => {
            if (source) {
                source.stop();
                source.disconnect();
            }
        });
        externalAudioLoopSources = []; // Kosongkan array sumber loop

        if (audioContext && audioContext.state !== 'closed') {
            audioContext.close();
        }

        isPlaying = false;
        isPaused = false;
        clearInterval(timerInterval);
        timerDiv.textContent = `Selesai 00:00 / ${formatDuration(totalDuration)}`;
        statusDiv.textContent = 'Selamat Program Anda Berjalan Sukses !!!';
        playBtn.disabled = false;
        playBtn.style.display = 'inline-block';
        pauseBtn.disabled = true;
        pauseBtn.style.display = 'none';
        stopBtn.disabled = true;
        pauseBtn.textContent = 'Pause ‚è∏Ô∏è';
        pauseOffset = 0;
    }

    // FUNGSI MODIFIKASI: Pause Audio
    function pauseAudio() {
        if (isPlaying) {
            isPlaying = false;
            isPaused = true;
            audioContext.suspend().then(() => {
                pauseBtn.textContent = 'Resume ‚èØÔ∏è';
                statusDiv.textContent = 'Pemutaran dijeda';
                clearInterval(timerInterval);
                pauseOffset = (Date.now() - playStartTime) / 1000 + pauseOffset;
            });
        }
    }

    // FUNGSI MODIFIKASI: Resume Audio
    function resumeAudio() {
        if (isPaused) {
            isPlaying = true;
            isPaused = false;
            audioContext.resume().then(() => {
                pauseBtn.textContent = 'Pause ‚è∏Ô∏è';
                statusDiv.textContent = 'Melanjutkan pemutaran...';
                playStartTime = Date.now();
                timerInterval = setInterval(updateStatusAndTimer, 1000);
            });
        }
    }


    // FUNGSI MODIFIKASI: Render untuk Download (Mencampur SBG dan Audio Eksternal + LOOP FIX)
    function renderAudioForDownload(duration) {
        const sampleRate = 44100;
        const offlineCtx = new OfflineAudioContext(2, duration * sampleRate, sampleRate);

        const masterGain = offlineCtx.createGain();
        masterGain.gain.setValueAtTime(MASTER_VOLUME, offlineCtx.currentTime); 
        masterGain.connect(offlineCtx.destination);

        const startTime = offlineCtx.currentTime;

        // LOGIKA AUDIO EKSTERNAL UNTUK DOWNLOAD (BARU - LOOP FIX)
        if (externalAudioBuffer) {
            const externalAudioDuration = externalAudioBuffer.duration;
            const totalDurationNeeded = duration; 
            const numLoops = Math.ceil(totalDurationNeeded / externalAudioDuration);
            
            let currentStartTime = 0; 
            
            for (let i = 0; i < numLoops; i++) {
                const durationToPlay = Math.min(externalAudioDuration, totalDurationNeeded - currentStartTime);
                
                if (durationToPlay > 0) {
                    const startPoint = startTime + currentStartTime;
                    const stopPoint = startTime + duration;
                    
                    const externalDownloadSource = offlineCtx.createBufferSource();
                    externalDownloadSource.buffer = externalAudioBuffer;
                    externalDownloadSource.loop = false;
                    externalDownloadSource.connect(masterGain); 
                    
                    // Start selalu dari 0 (karena ini render dari awal)
                    externalDownloadSource.start(startPoint, 0, durationToPlay);
                    externalDownloadSource.stop(stopPoint);
                    
                    currentStartTime += durationToPlay;
                }
            }
        }

        // LOGIKA BRAINWAVE GENERATOR (Tone dan Noise)
        const oscillatorL = offlineCtx.createOscillator();
        const oscillatorR = offlineCtx.createOscillator();

        const gainL = offlineCtx.createGain();
        const gainR = offlineCtx.createGain();
        const pannerL = offlineCtx.createStereoPanner();
        const pannerR = offlineCtx.createStereoPanner();
        pannerL.pan.setValueAtTime(-1, offlineCtx.currentTime);
        pannerR.pan.setValueAtTime(1, offlineCtx.currentTime);

        let pinkNoiseSource = null;
        let pinkNoiseGain = null;
        if (pinkNoiseToggle.checked) {
            pinkNoiseSource = offlineCtx.createBufferSource();
            // Durasi buffer pink noise harus sesuai dengan durasi render
            pinkNoiseSource.buffer = createPinkNoiseBuffer(offlineCtx, duration); 
            pinkNoiseSource.loop = false; // Tidak di-loop untuk offline render
            pinkNoiseGain = offlineCtx.createGain();
            pinkNoiseSource.connect(pinkNoiseGain);
            pinkNoiseGain.connect(masterGain);
            pinkNoiseSource.start(0);
        }

        oscillatorL.type = 'sine';
        oscillatorR.type = 'sine';
        oscillatorL.connect(gainL);
        gainL.connect(pannerL);
        pannerL.connect(masterGain);
        oscillatorR.connect(gainR);
        gainR.connect(pannerR);
        pannerR.connect(masterGain);

        // Penjadwalan SBG EVENTS
        sbgData.events.forEach(event => {
            const preset = sbgData.presets[event.preset];
            const scheduledTime = startTime + event.time;

            if (preset) {
                // Penjadwalan Tone dan Frekuensi (Binaural Beat Terjaga)
                gainL.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                gainR.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                oscillatorL.frequency.linearRampToValueAtTime(preset.freqL, scheduledTime);
                oscillatorR.frequency.linearRampToValueAtTime(preset.freqR, scheduledTime);
                if (pinkNoiseSource) {
                    // Penjadwalan Pink Noise
                    pinkNoiseGain.gain.linearRampToValueAtTime(preset.noiseVol, scheduledTime);
                }
            }
        });

        // Menghentikan semua sumber tepat pada durasi SBG
        oscillatorL.start(startTime);
        oscillatorR.start(startTime);
        oscillatorL.stop(duration);
        oscillatorR.stop(duration);
        if (pinkNoiseSource) {
            pinkNoiseSource.stop(duration);
        }
        
        return offlineCtx.startRendering();
    }


    function audioBufferToWavBlob(audioBuffer) {
        // Implementasi konversi Buffer ke WAV (tetap sama)
        const numOfChan = audioBuffer.numberOfChannels;
        const totalLength = audioBuffer.length * numOfChan * 2 + 44;
        const samples = new Int16Array(audioBuffer.length * numOfChan);
        
        for (let i = 0; i < audioBuffer.length; i++) {
            for (let channel = 0; channel < numOfChan; channel++) {
                const sample = audioBuffer.getChannelData(channel)[i];
                const intSample = Math.max(-1, Math.min(1, sample)) * 32767;
                samples[i * numOfChan + channel] = intSample;
            }
        }

        const buffer = new ArrayBuffer(totalLength);
        const view = new DataView(buffer);

        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numOfChan, true);
        view.setUint32(24, audioBuffer.sampleRate, true);
        view.setUint32(28, audioBuffer.sampleRate * 2 * numOfChan, true);
        view.setUint16(32, numOfChan * 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            view.setInt16(offset, samples[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    // FUNGSI MODIFIKASI: loadSbgData dipanggil HANYA setelah kata sandi benar
    function loadSbgData() {
        try {
            sbgData = parseSbg(sbgContentToLoad);
            if (sbgData && sbgData.events.length > 0) {
                sbgDuration = sbgData.events[sbgData.events.length - 1].time;
                totalDuration = sbgDuration;
                timerDiv.textContent = `Durasi 00:00 / ${formatDuration(totalDuration)}`;
                statusDiv.textContent = `Memuat Audio Eksternal...`; // Ubah status awal
                playBtn.disabled = true; // Nonaktifkan sampai audio eksternal selesai
                downloadBtn.disabled = false;
            } else {
                statusDiv.textContent = 'Gagal memproses file .sbg. Skylord Menolak Akses Anda';
                playBtn.disabled = true;
                downloadBtn.disabled = true;
            }
        } catch (error) {
            statusDiv.textContent = `Terjadi kesalahan saat memproses data: ${error.message}`;
            playBtn.disabled = true;
            downloadBtn.disabled = true;
        }
        
        loadExternalAudio();
    }
    
    // window.onload diubah. Player sekarang menampilkan layar kata sandi secara default.
    // loadSbgData() akan dipanggil dari checkPassword()

    // Event Listeners BARU untuk kata sandi
    submitPasswordBtn.addEventListener('click', checkPassword);
    passwordInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            checkPassword();
        }
    });

    // Event Listeners yang sudah ada
    playBtn.addEventListener('click', startAudio);
    stopBtn.addEventListener('click', stopAudio);
    
    pauseBtn.addEventListener('click', () => {
        if (isPaused) {
            resumeAudio();
        } else {
            pauseAudio();
        }
    });
    
    // Download Listener (Mencampur SBG dan Audio Eksternal)
    downloadBtn.addEventListener('click', () => {
        if (!sbgData || sbgData.events.length === 0) {
            statusDiv.textContent = 'Tidak ada file untuk diunduh.';
            return;
        }

        statusDiv.textContent = 'Skylord Membuat File Audio Mix, Mohon Tunggu...';
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        downloadBtn.disabled = true;
        
        if (isPlaying || isPaused) {
            stopAudio();
        }

        // renderAudioForDownload kini mencampur SBG dan Audio Eksternal
        renderAudioForDownload(totalDuration) 
            .then(audioBuffer => {
                const wavBlob = audioBufferToWavBlob(audioBuffer);
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'vibrasi-mix-alpha.wav'; // Nama file baru
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusDiv.textContent = 'File .wav Mix Berhasil Dibuat Oleh Skylord dan Siap Diunduh!';
                playBtn.disabled = false;
                downloadBtn.disabled = false;
            })
            .catch(error => {
                statusDiv.textContent = `Terjadi kesalahan saat membuat file audio: ${error.message}`;
                playBtn.disabled = false;
                downloadBtn.disabled = false;
            });
    });
</script>

</body>
</html>
